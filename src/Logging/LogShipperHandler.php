<?php

namespace AdminIntelligence\LogShipper\Logging;

use AdminIntelligence\LogShipper\Buffer\LogBufferInterface;
use AdminIntelligence\LogShipper\Jobs\ShipLogJob;
use AdminIntelligence\LogShipper\Utils\IpObfuscator;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Request;
use Illuminate\Support\Facades\Route;
use Monolog\Handler\AbstractProcessingHandler;
use Monolog\Level;
use Monolog\LogRecord;

class LogShipperHandler extends AbstractProcessingHandler
{
    public function __construct(Level $level = Level::Error, bool $bubble = true)
    {
        parent::__construct($level, $bubble);
    }

    protected function write(LogRecord $record): void
    {
        if (!config('log-shipper.enabled', true)) {
            return;
        }

        // Prevent infinite loops: Do not ship logs that are about shipping failures
        if (isset($record->context['log_shipper_failure'])) {
            return;
        }

        // Prevent infinite loops: Do not ship logs generated by the ShipLogJob itself
        if ($this->isRecursiveLog($record)) {
            return;
        }

        if (config('log-shipper.circuit_breaker.enabled', false) && Cache::has('log_shipper_dead_until')) {
            return;
        }

        $payload = $this->buildPayload($record);
        $sanitizedPayload = $this->sanitize($payload);
        
        // SECURITY: Prevent DoS by limiting payload size (default 1MB)
        $maxSize = config('log-shipper.max_payload_size', 1048576);
        $jsonPayload = json_encode($sanitizedPayload);
        
        // If json_encode fails, continue anyway (better to try sending than silently fail)
        if ($jsonPayload !== false) {
            $payloadSize = strlen($jsonPayload);
            
            if ($payloadSize > $maxSize) {
                // Truncate large payloads
                if (isset($sanitizedPayload['context'])) {
                    $sanitizedPayload['context'] = '[TRUNCATED: Payload too large]';
                    $sanitizedPayload['_truncated'] = true;
                    $sanitizedPayload['_original_size'] = $payloadSize;
                }
            }
        }

        // Batch Shipping
        if (config('log-shipper.batch.enabled', false)) {
            try {
                /** @var LogBufferInterface $buffer */
                $buffer = app(LogBufferInterface::class);
                $buffer->push($sanitizedPayload);

                return;
            } catch (\Throwable $e) {
                // If buffer fails, fall back to direct shipping
            }
        }

        $connection = config('log-shipper.queue_connection', 'default');
        $queue = config('log-shipper.queue_name', 'default');

        if ($connection === 'default') {
            $connection = config('queue.default');
        }

        try {
            ShipLogJob::dispatch($sanitizedPayload)
                ->onConnection($connection)
                ->onQueue($queue);
        } catch (\Throwable $e) {
            // If dispatching fails, try the fallback channel
            $fallbackChannel = config('log-shipper.fallback_channel');
            
            // CRITICAL: Prevent infinite loop if fallback channel is log_shipper
            if ($fallbackChannel && $fallbackChannel !== 'log_shipper') {
                try {
                    \Illuminate\Support\Facades\Log::channel($fallbackChannel)->error(
                        'LogShipper failed to dispatch job',
                        [
                            'exception' => $e->getMessage(),
                            'original_payload' => $sanitizedPayload
                        ]
                    );
                } catch (\Throwable $fallbackError) {
                    // If fallback fails, we really can't do anything else.
                }
            }
        }
    }

    protected function isRecursiveLog(LogRecord $record): bool
    {
        // PERFORMANCE: Only check error/warning logs (debug/info unlikely to be recursive)
        if ($record->level->value < Level::Warning->value) {
            return false;
        }
        
        // Check if the message mentions the job class
        if (str_contains($record->message, 'AdminIntelligence\LogShipper\Jobs\ShipLogJob')) {
            return true;
        }

        // Check if the exception context comes from the job
        if (isset($record->context['exception']) && $record->context['exception'] instanceof \Throwable) {
            $exception = $record->context['exception'];
            
            // Check trace string
            $trace = $exception->getTraceAsString();
            if (str_contains($trace, 'AdminIntelligence\LogShipper\Jobs\ShipLogJob')) {
                return true;
            }
            
            // Also check trace array for file paths
            foreach ($exception->getTrace() as $frame) {
                if (isset($frame['file']) && str_contains($frame['file'], 'LogShipper/Jobs/ShipLogJob')) {
                    return true;
                }
                if (isset($frame['class']) && str_contains($frame['class'], 'AdminIntelligence\LogShipper\Jobs\ShipLogJob')) {
                    return true;
                }
            }
        }

        return false;
    }

    protected function buildPayload(LogRecord $record): array
    {
        $contextConfig = config('log-shipper.send_context', []);

        $payload = [
            'level' => strtolower($record->level->name),
            'message' => $record->message,
            'context' => $this->filterSerializable($record->context),
            'datetime' => $record->datetime->format('Y-m-d H:i:s.u'),
            'channel' => $record->channel,
            'extra' => $this->filterSerializable($record->extra),
        ];

        // Add request context if available and configured
        if ($this->shouldSendContext('user_id', $contextConfig)) {
            $payload['user_id'] = $this->safeGetUserId();
        }

        if ($this->shouldSendContext('ip_address', $contextConfig)) {
            $ip = $this->safeGetRequestData('ip');
            if ($ip !== null && config('log-shipper.ip_obfuscation.enabled', false)) {
                $method = config('log-shipper.ip_obfuscation.method', 'mask');
                $ip = IpObfuscator::obfuscate($ip, $method);
            }
            $payload['ip_address'] = $ip;
        }

        if ($this->shouldSendContext('user_agent', $contextConfig)) {
            $payload['user_agent'] = $this->safeGetRequestData('userAgent');
        }

        if ($this->shouldSendContext('request_method', $contextConfig)) {
            $payload['request_method'] = $this->safeGetRequestData('method');
        }

        if ($this->shouldSendContext('request_url', $contextConfig)) {
            $payload['request_url'] = $this->safeGetRequestData('fullUrl');
        }

        if ($this->shouldSendContext('route_name', $contextConfig)) {
            $payload['route_name'] = $this->safeGetRouteData('name');
        }

        if ($this->shouldSendContext('controller_action', $contextConfig)) {
            $payload['controller_action'] = $this->safeGetRouteData('action');
        }

        if ($this->shouldSendContext('app_env', $contextConfig)) {
            $payload['app_env'] = config('app.env');
        }

        if ($this->shouldSendContext('app_debug', $contextConfig)) {
            $payload['app_debug'] = config('app.debug');
        }

        if ($this->shouldSendContext('referrer', $contextConfig)) {
            $payload['referrer'] = $this->safeGetRequestData('referrer');
        }

        return $payload;
    }

    protected function shouldSendContext(string $key, array $config): bool
    {
        return $config[$key] ?? false;
    }

    protected function safeGetUserId(): ?string
    {
        try {
            $id = Auth::id();

            return $id !== null ? (string) $id : null;
        } catch (\Throwable) {
            return null;
        }
    }

    protected function safeGetRequestData(string $type): ?string
    {
        try {
            return match ($type) {
                'ip' => Request::ip(),
                'userAgent' => Request::userAgent(),
                'method' => Request::method(),
                'fullUrl' => Request::fullUrl(),
                'referrer' => Request::header('referer'),
                default => null,
            };
        } catch (\Throwable) {
            return null;
        }
    }

    protected function safeGetRouteData(string $type): ?string
    {
        try {
            $route = Route::current();
            if (!$route) {
                return null;
            }

            return match ($type) {
                'name' => $route->getName(),
                'action' => $route->getActionName(),
                default => null,
            };
        } catch (\Throwable) {
            return null;
        }
    }

    protected function sanitize(array $data): array
    {
        $sensitiveFields = config('log-shipper.sanitize_fields', []);

        return $this->sanitizeRecursive($data, $sensitiveFields);
    }

    protected function sanitizeRecursive(array $data, array $sensitiveFields): array
    {
        foreach ($data as $key => $value) {
            if (is_array($value)) {
                $data[$key] = $this->sanitizeRecursive($value, $sensitiveFields);
            } elseif ($this->isSensitiveKey($key, $sensitiveFields)) {
                $data[$key] = '[REDACTED]';
            }
        }

        return $data;
    }

    protected function isSensitiveKey(string $key, array $sensitiveFields): bool
    {
        $lowerKey = strtolower($key);

        foreach ($sensitiveFields as $field) {
            $lowerField = strtolower($field);
            
            // SECURITY: Use strict matching to avoid false positives (e.g. "compass" matching "pass")
            // Matches: "password", "user_password", "password_confirmation", "api-key"
            if ($lowerKey === $lowerField || 
                str_ends_with($lowerKey, '_' . $lowerField) || 
                str_starts_with($lowerKey, $lowerField . '_') ||
                str_contains($lowerKey, '_' . $lowerField . '_') ||
                str_ends_with($lowerKey, '-' . $lowerField) || 
                str_starts_with($lowerKey, $lowerField . '-') ||
                str_contains($lowerKey, '-' . $lowerField . '-')) {
                return true;
            }
        }

        return false;
    }

    protected function filterSerializable(array $data): array
    {
        $filtered = [];

        foreach ($data as $key => $value) {
            // Skip closures and resources
            if ($value instanceof \Closure || is_resource($value)) {
                $filtered[$key] = '[FILTERED: ' . gettype($value) . ']';
                continue;
            }
            
            // SECURITY: Skip PDO and database connection objects to prevent credential leaks
            if ($value instanceof \PDO || $value instanceof \PDOStatement) {
                $filtered[$key] = '[FILTERED: Database Connection]';
                continue;
            }

            // Skip Throwable objects to avoid serialization issues with stack traces
            if ($value instanceof \Throwable) {
                $filtered[$key] = [
                    'class' => $value::class,
                    'message' => $value->getMessage(),
                    'code' => $value->getCode(),
                    'file' => $value->getFile(),
                    'line' => $value->getLine(),
                ];

                continue;
            }
            
            // Handle other objects that might not serialize properly
            if (is_object($value)) {
                if (method_exists($value, '__toString')) {
                    $filtered[$key] = (string) $value;
                } elseif ($value instanceof \JsonSerializable) {
                    $filtered[$key] = $value->jsonSerialize();
                } else {
                    $filtered[$key] = '[OBJECT: ' . get_class($value) . ']';
                }
                continue;
            }

            // Recursively filter arrays
            if (is_array($value)) {
                $filtered[$key] = $this->filterSerializable($value);
            } else {
                $filtered[$key] = $value;
            }
        }

        return $filtered;
    }
}
