<?php

namespace AdminIntelligence\LogShipper\Logging;

use AdminIntelligence\LogShipper\Jobs\ShipLogJob;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Request;
use Illuminate\Support\Facades\Route;
use Monolog\Handler\AbstractProcessingHandler;
use Monolog\Level;
use Monolog\LogRecord;

class LogShipperHandler extends AbstractProcessingHandler
{
    public function __construct(Level $level = Level::Error, bool $bubble = true)
    {
        parent::__construct($level, $bubble);
    }

    protected function write(LogRecord $record): void
    {
        if (!config('log-shipper.enabled', true)) {
            return;
        }

        // Prevent infinite loops: Do not ship logs that are about shipping failures
        if (isset($record->context['log_shipper_failure'])) {
            return;
        }

        // Prevent infinite loops: Do not ship logs generated by the ShipLogJob itself
        if ($this->isRecursiveLog($record)) {
            return;
        }

        if (config('log-shipper.circuit_breaker.enabled', false) && Cache::has('log_shipper_dead_until')) {
            return;
        }

        $payload = $this->buildPayload($record);
        $sanitizedPayload = $this->sanitize($payload);

        $connection = config('log-shipper.queue_connection', 'default');
        $queue = config('log-shipper.queue_name', 'default');

        if ($connection === 'default') {
            $connection = config('queue.default');
        }

        try {
            ShipLogJob::dispatch($sanitizedPayload)
                ->onConnection($connection)
                ->onQueue($queue);
        } catch (\Throwable $e) {
            // If dispatching fails (e.g. sync driver with connection error),
            // we silently fail to prevent crashing the application.
        }
    }

    protected function isRecursiveLog(LogRecord $record): bool
    {
        // Check if the message mentions the job class
        if (str_contains($record->message, 'AdminIntelligence\LogShipper\Jobs\ShipLogJob')) {
            return true;
        }

        // Check if the exception context comes from the job
        if (isset($record->context['exception']) && $record->context['exception'] instanceof \Throwable) {
            $trace = $record->context['exception']->getTraceAsString();
            if (str_contains($trace, 'AdminIntelligence\LogShipper\Jobs\ShipLogJob')) {
                return true;
            }
        }

        return false;
    }

    protected function buildPayload(LogRecord $record): array
    {
        $contextConfig = config('log-shipper.send_context', []);

        $payload = [
            'level' => strtolower($record->level->name),
            'message' => $record->message,
            'context' => $this->filterSerializable($record->context),
            'datetime' => $record->datetime->format('Y-m-d H:i:s.u'),
            'channel' => $record->channel,
            'extra' => $this->filterSerializable($record->extra),
        ];

        // Add request context if available and configured
        if ($this->shouldSendContext('user_id', $contextConfig)) {
            $payload['user_id'] = $this->safeGetUserId();
        }

        if ($this->shouldSendContext('ip_address', $contextConfig)) {
            $payload['ip_address'] = $this->safeGetRequestData('ip');
        }

        if ($this->shouldSendContext('user_agent', $contextConfig)) {
            $payload['user_agent'] = $this->safeGetRequestData('userAgent');
        }

        if ($this->shouldSendContext('request_method', $contextConfig)) {
            $payload['request_method'] = $this->safeGetRequestData('method');
        }

        if ($this->shouldSendContext('request_url', $contextConfig)) {
            $payload['request_url'] = $this->safeGetRequestData('fullUrl');
        }

        if ($this->shouldSendContext('route_name', $contextConfig)) {
            $payload['route_name'] = $this->safeGetRouteData('name');
        }

        if ($this->shouldSendContext('controller_action', $contextConfig)) {
            $payload['controller_action'] = $this->safeGetRouteData('action');
        }

        if ($this->shouldSendContext('app_env', $contextConfig)) {
            $payload['app_env'] = config('app.env');
        }

        if ($this->shouldSendContext('app_debug', $contextConfig)) {
            $payload['app_debug'] = config('app.debug');
        }

        if ($this->shouldSendContext('referrer', $contextConfig)) {
            $payload['referrer'] = $this->safeGetRequestData('referrer');
        }

        return $payload;
    }

    protected function shouldSendContext(string $key, array $config): bool
    {
        return $config[$key] ?? false;
    }

    protected function safeGetUserId(): ?string
    {
        try {
            $id = Auth::id();

            return $id !== null ? (string) $id : null;
        } catch (\Throwable) {
            return null;
        }
    }

    protected function safeGetRequestData(string $type): ?string
    {
        try {
            return match ($type) {
                'ip' => Request::ip(),
                'userAgent' => Request::userAgent(),
                'method' => Request::method(),
                'fullUrl' => Request::fullUrl(),
                'referrer' => Request::header('referer'),
                default => null,
            };
        } catch (\Throwable) {
            return null;
        }
    }

    protected function safeGetRouteData(string $type): ?string
    {
        try {
            $route = Route::current();
            if (!$route) {
                return null;
            }

            return match ($type) {
                'name' => $route->getName(),
                'action' => $route->getActionName(),
                default => null,
            };
        } catch (\Throwable) {
            return null;
        }
    }

    protected function sanitize(array $data): array
    {
        $sensitiveFields = config('log-shipper.sanitize_fields', []);

        return $this->sanitizeRecursive($data, $sensitiveFields);
    }

    protected function sanitizeRecursive(array $data, array $sensitiveFields): array
    {
        foreach ($data as $key => $value) {
            if (is_array($value)) {
                $data[$key] = $this->sanitizeRecursive($value, $sensitiveFields);
            } elseif ($this->isSensitiveKey($key, $sensitiveFields)) {
                $data[$key] = '[REDACTED]';
            }
        }

        return $data;
    }

    protected function isSensitiveKey(string $key, array $sensitiveFields): bool
    {
        $lowerKey = strtolower($key);

        foreach ($sensitiveFields as $field) {
            if (str_contains($lowerKey, strtolower($field))) {
                return true;
            }
        }

        return false;
    }

    protected function filterSerializable(array $data): array
    {
        $filtered = [];

        foreach ($data as $key => $value) {
            // Skip closures and resources
            if ($value instanceof \Closure || is_resource($value)) {
                continue;
            }

            // Skip Throwable objects to avoid serialization issues with stack traces
            if ($value instanceof \Throwable) {
                $filtered[$key] = [
                    'class' => $value::class,
                    'message' => $value->getMessage(),
                    'code' => $value->getCode(),
                    'file' => $value->getFile(),
                    'line' => $value->getLine(),
                ];
                continue;
            }

            // Recursively filter arrays
            if (is_array($value)) {
                $filtered[$key] = $this->filterSerializable($value);
            } else {
                $filtered[$key] = $value;
            }
        }

        return $filtered;
    }
}
